#!/bin/bash

# branch-lock - Securely protect or unprotect branches across multiple GitHub repositories
# Usage: ./branch-lock [lock|unlock]
# Dependencies: gh (GitHub CLI), yq
# Configuration: branch-lock.yaml
# Author: GermÃ¡n Aliprandi - https://github.com/galiprandi  
# License: MIT

set -uo pipefail

# Allow overriding GitHub CLI for testing
GH_CMD=${GH_CMD:-gh}

# Colors
Cyan='\033[0;36m'
Green='\033[0;32m'
Yellow='\033[1;33m'
Red='\033[0;31m'
Bold='\033[1m'
Dim='\033[2m'
NC='\033[0m'

# Icons
IC_INFO='â„¹'
IC_OK='âœ”'
IC_ERR='âœ˜'
IC_STEP='â–¶'
IC_LOCK='ðŸ”’'
IC_UNLOCK='ðŸ”“'
IC_STAR='â˜…'

# Log helpers
log_step() { printf "%b %b\n" "${Cyan}${IC_STEP}${NC}" "$1"; }
log_ok()   { printf "%b %b\n" "${Green}${IC_OK}${NC}" "$1"; }
log_err()  { printf "%b %b\n" "${Red}${IC_ERR}${NC}" "$1"; }
log_info() { printf "%b %b\n" "${Cyan}${IC_INFO}${NC}" "$1"; }
log_dim()  { printf "%b\n"   "${Dim}$1${NC}"; }

# Config defaults and flags
CONFIG="branch-lock.yaml"
ACTION=""
YES=0
QUIET=0
LOCK_BRANCH_FLAG=0

# Config check
check_config() {
  [[ -f "$CONFIG" ]] || {
    printf "${Red}[ERROR] Configuration file '$CONFIG' not found${NC}\n"
    # Create default config (guidance)
    cat <<EOF > "$CONFIG"
# lock:
#   required_approvals: 6
# unlock:
#   required_approvals: 1
#
# repositories:
#   - org: galiprandi
#     repo: bash
#     branch: main
#     # Optional per-repository overrides (if omitted, global lock/unlock settings are used)
#     # lock:
#     #   required_approvals: 6
#     # unlock:
#     #   required_approvals: 1
EOF
    exit 1
  }
}

# Dependencies check
check_deps() {
  for cmd in "$GH_CMD" yq; do
    if ! command -v "$cmd" &> /dev/null; then
      printf "${Red}[ERROR] %s is not installed. Install: https://cli.github.com   | https://github.com/mikefarah/yq  ${NC}\n" "$cmd"
      exit 1
    fi
  done
}

# GitHub auth check
check_auth() {
  if ! "$GH_CMD" auth status &> /dev/null; then
    printf "${Red}[ERROR] Not authenticated with GitHub CLI. Run 'gh auth login'${NC}\n"
    exit 1
  fi
}

# YAML helper (thin wrapper)
yq_get() { yq eval "$1" "$CONFIG" 2>/dev/null; }

# Load repos from config
load_repos() {
  check_config

  if ! yq_get '.repositories' >/dev/null; then
    printf "${Red}[ERROR] Invalid YAML format or missing 'repositories' in '$CONFIG'${NC}\n"
    exit 1
  fi

  REPOS=()
  while IFS= read -r line; do REPOS+=("$line"); done \
    < <(yq_get '.repositories[] | "\(.org)/\(.repo) \(.branch)"')

  [[ ${#REPOS[@]} -gt 0 ]] || {
    printf "${Red}[ERROR] No repositories defined in '$CONFIG'${NC}\n"
    exit 1
  }
}

# Resolve approvals with precedence: per-repo > global(default)
resolve_approvals() {
  local action="$1" qrepo="$2" val
  if [[ "$action" == "lock" ]]; then
    val=$(yq_get "$qrepo.lock.required_approvals")
    [[ "$val" == "null" ]] && val=$(yq_get '.lock.required_approvals // 6')
  else
    val=$(yq_get "$qrepo.unlock.required_approvals")
    [[ "$val" == "null" ]] && val=$(yq_get '.unlock.required_approvals // 0')
  fi
  echo "$val"
}

# Cap approvals to GitHub limits
cap_approvals() {
  local a="$1"
  (( a>6 )) && a=6
  (( a<0 )) && a=0
  echo "$a"
}

# Resolve lock_branch with precedence: CLI > per-repo > global > unset
resolve_lock_branch() {
  local action="$1" qrepo="$2" lb="__unset__" tmp
  if [[ "$LOCK_BRANCH_FLAG" -eq 1 ]]; then
    if [[ "$action" == "lock" ]]; then lb=true; else lb=false; fi
    echo "$lb"; return
  fi
  if [[ "$action" == "lock" ]]; then tmp=$(yq_get "$qrepo.lock.lock_branch"); else tmp=$(yq_get "$qrepo.unlock.lock_branch"); fi
  if [[ "$tmp" != "null" ]]; then echo "$tmp"; return; fi
  if [[ "$action" == "lock" ]]; then tmp=$(yq_get '.lock.lock_branch'); else tmp=$(yq_get '.unlock.lock_branch'); fi
  if [[ "$tmp" != "null" ]]; then echo "$tmp"; else echo "__unset__"; fi
}

# Build JSON payload string. Emits to stdout.
build_payload() {
  local approvals="$1" lbval="$2" extra=""
  if [[ "$lbval" != "__unset__" ]]; then
    if [[ "$lbval" == "true" ]]; then
      extra=$',\n  "lock_branch": true'
    else
      extra=$',\n  "lock_branch": false'
    fi
  fi
  cat <<JSON
{
  "required_pull_request_reviews": {
    "required_approving_review_count": $approvals
  },
  "required_status_checks": null,
  "enforce_admins": false,
  "restrictions": null$extra
}
JSON
}

# Confirm action
confirm() {
  local action=$1
  if [[ $QUIET -ne 1 ]]; then
    log_info "Action    ${Bold}$action${NC}"
    log_info "Targets   ${Bold}${#REPOS[@]}${NC} repos"
    printf "\n"
  fi
  [[ $YES -eq 1 ]] && return 0
  read -rp $'â–¶ Proceed? (yes/N): ' CONFIRM
  [[ "$CONFIRM" == "yes" ]] || {
    printf "${Red}[ABORT] Operation cancelled${NC}\n"
    exit 0
  }
}

# Apply or update protection (single function for lock/unlock)
apply_protection() {
  local action="$1"; shift
  local full="$1" branch="$2"
  local _pfx=""
  [[ -n "${CURRENT_IDX:-}" && -n "${TOTAL_COUNT:-}" ]] && _pfx="[${CURRENT_IDX}/${TOTAL_COUNT}] "

  # Derive org/repo for per-entry lookup
  local org repo
  org=${full%%/*}
  repo=${full##*/}

  # Resolve approvals and lock_branch
  local approvals qrepo payload out t0 dt
  qrepo=".repositories[] | select(.org==\"$org\" and .repo==\"$repo\" and .branch==\"$branch\")"
  if [[ "$action" == "lock" ]]; then
    log_step "${_pfx}${IC_LOCK} Protecting ${Bold}${full}@${branch}${NC}"
  else
    log_step "${_pfx}${IC_UNLOCK} Updating protection for ${Bold}${full}@${branch}${NC}"
  fi
  approvals=$(resolve_approvals "$action" "$qrepo")
  approvals=$(cap_approvals "$approvals")
  local lbval
  lbval=$(resolve_lock_branch "$action" "$qrepo")

  payload=$(build_payload "$approvals" "$lbval")
  t0=$SECONDS
  if out=$("$GH_CMD" api "repos/$full/branches/$branch/protection" --method PUT -H "Accept: application/vnd.github+json" --input - 2>&1 <<< "$payload"); then
    dt=$((SECONDS - t0))
    if [[ "$action" == "lock" ]]; then
      log_ok "Locked with ${Bold}${approvals}${NC} reviewer(s) ${Dim}(${dt}s)${NC}"
    else
      log_ok "Set reviewers to ${Bold}${approvals}${NC} ${Dim}(${dt}s)${NC}"
    fi
    return 0
  else
    if [[ "$action" == "lock" ]]; then
      log_err "Failed to lock"
    else
      log_err "Failed to update reviewers on unlock"
    fi
    log_dim "$out"
    return 1
  fi
}

# Main
main() {
  # Default config
  CONFIG="branch-lock.yaml"

  # Parse flags and action
  ACTION=""
  i=1
  while [[ $i -le $# ]]; do
    arg="${!i}"
    case "$arg" in
      --yes|-y) YES=1 ;;
      --quiet|-q) QUIET=1 ;;
      --lock-branch)
        LOCK_BRANCH_FLAG=1
        ;;
      --config)
        i=$((i + 1))
        CONFIG="${!i}"
        ;;
      --config=*)
        CONFIG="${arg#--config=}"
        ;;
      lock|unlock) ACTION="$arg" ;;
      *)
        printf "Unknown argument: %s\n" "$arg" >&2
        exit 1
        ;;
    esac
    i=$((i + 1))
  done

  if [[ -z "$ACTION" ]]; then
    printf "Usage: %s [options] <lock|unlock>\n" "$(basename "$0")"
    printf "Options:\n"
    printf "  --yes, -y       Skip confirmation\n"
    printf "  --quiet, -q     Minimal output (hide header and action/targets)\n"
    printf "  --config <file> Use custom config file\n"
    printf "  --lock-branch   Also toggle 'lock_branch' protection (true on lock, false on unlock)\n"
    exit 1
  fi

  [[ $QUIET -ne 1 ]] && printf "%b\n\n" "${Cyan}${IC_STAR} ${Bold}branch-lock v1.0${NC} â€” Multi-Repo Branch Protection Manager"

  check_deps
  check_auth
  load_repos
  confirm "$ACTION"

  local success=0 error=0
  TOTAL_COUNT=${#REPOS[@]}
  CURRENT_IDX=0
  for entry in "${REPOS[@]}"; do
    CURRENT_IDX=$((CURRENT_IDX + 1))
    local full_repo=$(awk '{print $1}' <<< "$entry")
    local target_branch=$(awk '{print $2}' <<< "$entry")

    if [[ -z "$full_repo" || -z "$target_branch" ]]; then
      printf "${Red}[SKIP] Invalid entry: %s${NC}\n" "$entry"
      ((error++))
      continue
    fi

    if apply_protection "$ACTION" "$full_repo" "$target_branch"; then
      ((success++))
    else
      ((error++))
    fi
  done

  printf "\n"
  if [[ $error -eq 0 ]]; then
    log_ok "Completed: ${Bold}${success}${NC} success, ${Bold}0${NC} errors"
  else
    log_err "Completed: ${Bold}${success}${NC} success, ${Bold}${error}${NC} error(s)"
    log_info "Check permissions or repository/branch names"
  fi

  exit 0
}

main "$@"