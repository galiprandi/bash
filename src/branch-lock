#!/bin/bash

# branch-lock - Securely protect or unprotect branches across multiple GitHub repositories
# Usage: ./branch-lock [lock|unlock]
# Dependencies: gh (GitHub CLI), yq

set -euo pipefail

# Colors
Cyan='\033[0;36m'
Green='\033[0;32m'
Yellow='\033[1;33m'
Red='\033[0;31m'
NC='\033[0m'

# Config
CONFIG="branch-lock.yaml"

# Dependencies check
check_deps() {
  for cmd in gh yq; do
    if ! command -v "$cmd" &> /dev/null; then
      printf "${Red}[ERROR] %s is not installed. Install: https://cli.github.com | https://github.com/mikefarah/yq${NC}\n" "$cmd"
      exit 1
    fi
  done
}

# GitHub auth check
check_auth() {
  if ! gh auth status &> /dev/null; then
    printf "${Red}[ERROR] Not authenticated with GitHub CLI. Run 'gh auth login'${NC}\n"
    exit 1
  fi
}

# Config check
check_config() {
  [[ -f "$CONFIG" ]] || {
    printf "${Red}[ERROR] Configuration file '$CONFIG' not found${NC}\n"
    
    # Create default config
    cat <<EOF > "$CONFIG"
# repositories:
#   - org: galiprandi
#     repo: bash
#     branch: main
#     protection:
#       # Enforce rules for admins too
#       enforce_admins: true
#       # Allow/disallow force pushes and deletions on protected branch
#       allow_force_pushes: false
#       allow_deletions: false
#       # Required status checks (set CI contexts if needed)
#       required_status_checks:
#         strict: true
#         contexts: []
#       # Pull request review requirements
#       required_pull_request_reviews:
#         required_approving_review_count: 3
#         require_code_owner_reviews: false
#         dismiss_stale_reviews: false
#         require_last_push_approval: false
#       # Restrictions on who can push (null by default; configure rulesets if you need granular control)
#       restrictions: null
EOF
    exit 1
  }
}

# Load repos from config
load_repos() {
  check_config

  if ! yq eval '.repositories' "$CONFIG" &> /dev/null; then
    printf "${Red}[ERROR] Invalid YAML format or missing 'repositories' in '$CONFIG'${NC}\n"
    exit 1
  fi

  REPOS=()
  while IFS= read -r line; do
    REPOS+=("$line")
  done < <(yq eval '.repositories[] | "\(.org)/\(.repo) \(.branch)"' "$CONFIG" 2>/dev/null)
  [[ ${#REPOS[@]} -gt 0 ]] || {
    printf "${Red}[ERROR] No repositories defined in '$CONFIG'${NC}\n"
    exit 1
  }
}

# Confirm action
confirm() {
  local action=$1
  printf "${Cyan}Action:    %s${NC}\n" "$action"
  printf "${Cyan}Targets:   %d repositories${NC}\n" "${#REPOS[@]}"
  printf "\n"
  read -rp "Proceed? (yes/N): " CONFIRM
  [[ "$CONFIRM" == "yes" ]] || {
    printf "${Red}[ABORT] Operation cancelled${NC}\n"
    exit 0
  }
}

# Apply protection
protect() {
  local full="$1" branch="$2"
  printf "[LOCK] Protecting %s@%s... " "$full" "$branch"
  local out
  local payload
  # Derive org/repo for per-entry lookup
  local org repo
  org=${full%%/*}
  repo=${full##*/}

  # Defaults
  local def_enforce_admins=true
  local def_allow_force_pushes=false
  local def_allow_deletions=false
  local def_strict=true
  local def_contexts='[]'
  local def_rpr_count=3
  local def_require_co=false
  local def_dismiss_stale=false
  local def_require_last_push_approval=false

  # Resolve values from YAML (fall back to defaults)
  local qprefix=".repositories[] | select(.org==\"$org\" and .repo==\"$repo\" and .branch==\"$branch\") | .protection"
  local enforce_admins=$(yq eval "$qprefix.enforce_admins // $def_enforce_admins" "$CONFIG")
  local allow_force_pushes=$(yq eval "$qprefix.allow_force_pushes // $def_allow_force_pushes" "$CONFIG")
  local allow_deletions=$(yq eval "$qprefix.allow_deletions // $def_allow_deletions" "$CONFIG")
  local strict=$(yq eval "$qprefix.required_status_checks.strict // $def_strict" "$CONFIG")
  local contexts=$(yq -o=json eval "$qprefix.required_status_checks.contexts // $def_contexts" "$CONFIG")
  local required_approving_review_count=$(yq eval "$qprefix.required_pull_request_reviews.required_approving_review_count // $def_rpr_count" "$CONFIG")
  local require_code_owner_reviews=$(yq eval "$qprefix.required_pull_request_reviews.require_code_owner_reviews // $def_require_co" "$CONFIG")
  local dismiss_stale_reviews=$(yq eval "$qprefix.required_pull_request_reviews.dismiss_stale_reviews // $def_dismiss_stale" "$CONFIG")
  local require_last_push_approval=$(yq eval "$qprefix.required_pull_request_reviews.require_last_push_approval // $def_require_last_push_approval" "$CONFIG")

  # Build JSON payload (always include objects with resolved values)
  payload=$(cat <<JSON
{
  "required_pull_request_reviews": {
    "required_approving_review_count": $required_approving_review_count,
    "require_code_owner_reviews": $require_code_owner_reviews,
    "dismiss_stale_reviews": $dismiss_stale_reviews,
    "require_last_push_approval": $require_last_push_approval
  },
  "required_status_checks": { "strict": $strict, "contexts": $contexts },
  "enforce_admins": $enforce_admins,
  "restrictions": null,
  "allow_force_pushes": $allow_force_pushes,
  "allow_deletions": $allow_deletions
}
JSON
)
  if out=$(gh api "repos/$full/branches/$branch/protection" \
    --method PUT \
    -H "Accept: application/vnd.github+json" \
    --input - 2>&1 <<< "$payload"); then
    printf "${Green}‚úî PROTECTED${NC}\n"
    return 0
  else
    printf "${Red}‚úò FAILED${NC}\n"
    printf "${Yellow}%s${NC}\n" "$out"
    return 1
  fi
}

# Remove protection
unprotect() {
  local full="$1" branch="$2"
  printf "[UNLOCK] Unprotecting %s@%s... " "$full" "$branch"
  if gh api "repos/$full/branches/$branch/protection" --method DELETE --silent 2>/dev/null; then
    printf "${Green}üîì UNPROTECTED${NC}\n"
    return 0
  elif ! gh api "repos/$full/branches/$branch/protection" --silent &> /dev/null; then
    printf "${Green}‚è© Already unprotected${NC}\n"
    return 0
  else
    printf "${Red}‚úò FAILED${NC}\n"
    # show error on failure
    gh api "repos/$full/branches/$branch/protection" --method DELETE 2>&1 | sed 's/^/  /'
    return 1
  fi
}

# Main
main() {
  printf "${Cyan}üîê branch-lock v1.0 ‚Äî Multi-Repo Branch Protection Manager${NC}\n"
  printf "\n"

  check_deps
  check_auth
  load_repos

  case "${1:-}" in
    lock|unlock)
      ACTION="$1"
      ;;
    *)
      printf "Usage: %s [lock|unlock]\n" "$(basename "$0")"
      printf "  lock   %s\n" "Enable branch protection (prevent direct pushes)"
      printf "  unlock %s\n" "Disable branch protection"
      exit 1
      ;;
  esac

  confirm "$ACTION"

  local success=0 error=0
  for entry in "${REPOS[@]}"; do
    local full_repo=$(awk '{print $1}' <<< "$entry")
    local target_branch=$(awk '{print $2}' <<< "$entry")

    if [[ -z "$full_repo" || -z "$target_branch" ]]; then
      printf "${Red}[SKIP] Invalid entry: %s${NC}\n" "$entry"
      ((error++))
      continue
    fi

    if [[ "$ACTION" == "lock" ]]; then
      protect "$full_repo" "$target_branch" && ((success++)) || ((error++))
    else
      unprotect "$full_repo" "$target_branch" && ((success++)) || ((error++))
    fi
  done

  printf "\n"
  printf "${Green}[OK] Completed: %d success, %d error(s)${NC}\n" "$success" "$error"
  [[ $error -gt 0 ]] && printf "${Yellow}[NOTE] Check permissions or repository/branch names${NC}\n"
}

main "$@"